[html::author "Colin McCormack"]
[mypage::header "htaccess editor"]
<p>
[
 Doc_Dynamic

 proc get_AllowDeny {op} {
     foreach {v1 v2} [split [ncgi::value order_$op] ,] {break}
     return "[string totitle $v1],[string totitle $v2]"
 }

 proc MyAuthParseHtaccess {sock file {infoName ""}} {
     if {$infoName == ""} {
	 upvar #0 auth$file info
	 set infoName auth$file
     } else {
	 upvar #0 $infoName info
     }
     
     set mtime [file mtime $file]
     if {![info exists info] || ($mtime > $info(htaccessp,mtime))} {
	 # Parse .htaccess file
	 foreach i [array names info "htaccessp*"] {
	     unset info($i)
	 }
	 set info(htaccessp,mtime) $mtime
	 set info(htaccessp,userfile) {}
	 set info(htaccessp,groupfile) {}
	 if {[catch {open $file} in]} {
	     return 1
	 }
	 set state [list vars]
	 foreach line [split [read $in] \n] {
	     #puts stderr "$state $line"
	     if {[regexp ^# $line] || [string length [string trim $line]] == 0} {
		  continue
	      }
	     if {[regexp <(.+)> $line x tag]} {
		 #puts stderr "var tag $tag"
		 set line $tag
	     }
	     set words [split $line]
	     set cmd [string tolower [lindex $words 0]]
	     if {[catch {
		 #puts stderr "var eval Ht-$cmd $infoName [lrange $words 1 end]"
		 eval Ht-$cmd $infoName [lrange $words 1 end]
	     } err]} {
		 Log $sock Error $err
	     }
	     }
	     close $in
	 }
	 return 1
     }
 ]
<form action='$page(url)' method='POST'>
<table>
[
 # set blank defaults
 ::ncgi::setDefaultValue submit Load
 ::ncgi::setDefaultValue userfile [pwd]/htaccess/passwd
 ::ncgi::setDefaultValue groupfile [pwd]/htaccess/group
 ::ncgi::setDefaultValue name "Tclhttpd Authentication Realm"
 ::ncgi::setDefaultValue type Digest

 ::ncgi::setDefaultValue order_GET allow,deny
 ::ncgi::setDefaultValue network_allow_GET ""
 ::ncgi::setDefaultValue network_deny_GET ""
 ::ncgi::setDefaultValue require_GET_group ""
 ::ncgi::setDefaultValue require_GET_user ""

 ::ncgi::setDefaultValue order_POST deny,allow
 ::ncgi::setDefaultValue network_allow_POST 127.0.0.1
 ::ncgi::setDefaultValue network_deny_POST all
 ::ncgi::setDefaultValue require_POST_group ""
 ::ncgi::setDefaultValue require_POST_user ""

 # Save the file
 if {[::ncgi::value submit] != "Load"} {
     set content "# Generated by $page(url)\n"
     foreach {tag keyword} {userfile AuthUserFile
	 groupfile AuthGroupFile
	 name AuthName
	 type AuthType
     } {
	 append content "$keyword [string map {" " ""} [ncgi::value $tag]]\n"
     }
     
     foreach op {GET POST} {
	 append content "\n<Limit $op>\n"
	 foreach {tag keyword} [subst {
	     order_${op} order
	     network_deny_${op} "deny from"
	     network_allow_${op} "allow from"
	     require_${op}_group "require group"
	     require_${op}_user "require user"
	 }] {
	     set val [ncgi::value $tag]
	     if {$val != ""} {
		 append content "$keyword $val\n"
	     }
	 }
	 
	 append content "</Limit>\n"
     }
     
     # write the file out
     if {[::ncgi::value submit] == "Update"} {
	 catch {
	     file copy -force [file join $directory .htaccess] [file join $directory .htaccess-bak]
	 }
     }
     set fd [open [file join $directory .htaccess] w]
     puts $fd $content
     close $fd

     #return "<p><b>.htaccess file</b><br><pre>[protect_text $content]</pre>"
 }

 # Output the top part of the form
 global Httpd
 upvar #0 htaccess$Httpd(currentSocket) htaccess
 catch {unset htaccess}

 set directory [ncgi::value directory]
 if {$directory != ""} {
     if {[file exists [file join $directory .htaccess]]} {
	 # we have been given a directory - fetch and parse its contents
	 if {[catch {
	     MyAuthParseHtaccess $Httpd(currentSocket) \
		 [file join $directory .htaccess] \
		 htaccess$Httpd(currentSocket)} err]} {
	     global errorInfo
	     return [::html::row $err][::html::row $errorInfo]
	 }

	 foreach tag {userfile groupfile name type
	     order_GET network_deny_GET network_allow_GET
	     require_GET_group require_GET_user
	     order_POST network_deny_POST network_allow_POST
	     require_POST_group require_POST_user
	 } {
	     set ttag "htaccessp,[string map {_ ,} $tag]"
	     if {[info exists htaccess($ttag)]} {
		 ::ncgi::setValue $tag $htaccess($ttag)
	     }
	 }
	 set submit "Update"
     } else {
	 # new file - use defaults
	 set submit "Create"
     }

     set html [::html::foreach {tag var} [subst {
	 "Directory" directory
	 "Name" name
	 "<a href='user.html?file=[::html::quoteFormValue [ncgi::value userfile]]'>User File</a>" userfile
	 "<a href='group.html?file=[::html::quoteFormValue [ncgi::value groupfile]]'>Group File</a>" groupfile

     }] {
	     [html::textInputRow $tag  $var]
	 }]
     return ${html}[html::row "Type" \
			[html::radioSet type {&nbsp;} {
			    digest Digest
			    basic Basic
			} [ncgi::value type]]]
 } else {
     # we have not been given a directory - use default
     global Config
     ::ncgi::setDefaultValue directory [file join $Config(docRoot) htaccess]
     set submit "Load"
     return [html::textInputRow  Directory directory]
 }

]
</table>
[
 if {$submit != "Load"} {
     # Output the detailed File form
     return [::html::foreach op {GET POST} {
	 <p><table border='1'>
	 <tr><th colspan='2'>$op Authorization</th></tr>
	 [html::textInputRow "Require User" require_${op}_user]
	 [html::textInputRow "Require Group" require_${op}_group]
	 [html::row Order [html::radioSet order_$op {&nbsp;} {
	     "Deny,Allow" deny,allow
	     "Allow,Deny" allow,deny
	 } [get_AllowDeny $op]]]
	 [html::textInputRow "Allow $op From" network_allow_$op]
	 [html::textInputRow "Deny $op From" network_deny_$op]
	 </table>
     }]
 }
]

<p>[::html::submit "$submit"]
</form>

[if {[ncgi::value debug] == 1} {
    # debugging output
    return [subst {
	<p><b>htaccess Values</b><br>
	[html::tableFromArray htaccess "border=1"]
	<p><b>CGI Values</b><br>
	[html::tableFromList [ncgi::nvlist] "border=1"]
	<p>
	<b>Environment</b><br>
	[html::tableFromArray ::env "border=1" *]
    }]
}]

[mypage::footer]
